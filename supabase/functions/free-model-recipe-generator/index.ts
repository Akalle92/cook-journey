
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

// CORS headers for browser requests
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Handle CORS preflight requests
function handleCors(req: Request) {
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      headers: corsHeaders,
    });
  }
}

// Serve HTTP requests
serve(async (req) => {
  // Handle CORS if needed
  const corsResponse = handleCors(req);
  if (corsResponse) return corsResponse;
  
  try {
    // Create Supabase client with the project URL and service key
    const supabaseClient = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "" // Use service role key for unrestricted access
    );
    
    // Parse request body
    let requestData;
    try {
      requestData = await req.json();
    } catch (error) {
      console.error("Error parsing request:", error);
      throw new Error("Invalid request format");
    }
    
    const { url, userId } = requestData;
    
    if (!url) {
      throw new Error("URL is required");
    }
    
    if (!userId) {
      throw new Error("User ID is required");
    }

    console.log(`Processing URL: ${url} for User: ${userId}`);
    
    // Step 1: Try to extract recipe data using the existing extractor
    let recipeData = null;
    let extractionResult = null;
    
    try {
      console.log("Attempting initial recipe extraction with instagram-recipe-extractor");
      extractionResult = await supabaseClient.functions.invoke('instagram-recipe-extractor', {
        body: { url, userId }
      });
      
      if (extractionResult.error) {
        console.log("Error from recipe extractor:", extractionResult.error);
      } else if (extractionResult.data && extractionResult.data.status === 'success') {
        console.log("Recipe extraction successful:", extractionResult.data.method);
        recipeData = extractionResult.data.data;
      } else {
        console.log("Recipe extraction unsuccessful:", extractionResult.data);
      }
    } catch (error) {
      console.error("Error calling instagram-recipe-extractor:", error);
      // Continue with the free model even if extraction fails
    }
    
    // Step 2: Generate or enhance recipe using a free model approach
    let enhancedRecipe;
    const enhancementSource = recipeData ? "extraction" : "url-only";
    
    try {
      console.log(`Generating recipe with free model (source: ${enhancementSource})`);
      enhancedRecipe = await generateRecipeWithFreeModel(url, recipeData);
      
      if (!enhancedRecipe) {
        throw new Error("Failed to generate recipe with free model");
      }
      
      console.log("Successfully generated recipe data");
    } catch (error) {
      console.error("Error generating recipe with free model:", error);
      // If we have initial extraction data but free model enhancement failed, use the original data
      if (recipeData) {
        console.log("Falling back to original extracted recipe data");
        enhancedRecipe = recipeData;
      } else {
        throw new Error(`Failed to generate recipe: ${error.message}`);
      }
    }
    
    // Step 3: Save the enhanced recipe to Supabase
    try {
      // Ensure we have user_id in the recipe data
      enhancedRecipe.user_id = userId;
      enhancedRecipe.source_url = url;
      
      // Add attribution for the enhancement
      if (!enhancedRecipe.description) {
        enhancedRecipe.description = "";
      }
      
      if (enhancementSource === "extraction") {
        enhancedRecipe.description += "\n\nRecipe extracted and enhanced with free AI.";
      } else {
        enhancedRecipe.description += "\n\nRecipe generated by free AI based on the provided URL.";
      }
      
      // Save to Supabase
      console.log("Saving enhanced recipe to database");
      const { data: savedRecipe, error } = await supabaseClient
        .from('recipes')
        .insert([enhancedRecipe])
        .select()
        .single();
      
      if (error) {
        console.error("Error saving enhanced recipe:", error);
        throw new Error(`Failed to save recipe: ${error.message}`);
      }
      
      // Return the saved recipe with enhancement info
      return new Response(
        JSON.stringify({
          status: "success",
          data: savedRecipe,
          enhancementSource,
          extraction: extractionResult?.data || null
        }),
        {
          headers: { 
            "Content-Type": "application/json",
            ...corsHeaders
          },
        }
      );
    } catch (error) {
      console.error("Error saving enhanced recipe:", error);
      throw new Error(`Failed to save enhanced recipe: ${error.message}`);
    }
  } catch (error) {
    // Return error response
    console.error("Error processing URL with free model recipe generator:", error);
    return new Response(
      JSON.stringify({
        status: "error",
        message: error.message,
      }),
      {
        status: 400,
        headers: { 
          "Content-Type": "application/json",
          ...corsHeaders
        },
      }
    );
  }
});

// Function to generate a recipe using rule-based approach (completely free, no external API)
async function generateRecipeWithFreeModel(url: string, existingData: any): Promise<any> {
  // If we already have extracted data, use it as a base
  if (existingData) {
    return enhanceExistingRecipe(existingData);
  }
  
  // Get the webpage content to extract information
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch URL: ${response.status}`);
    }
    
    const html = await response.text();
    
    // Extract recipe title (basic approach)
    const titleMatch = html.match(/<title[^>]*>(.*?)<\/title>/i);
    const title = titleMatch ? titleMatch[1].replace(/\s*\|.*$/, '') : 'Recipe from ' + new URL(url).hostname;
    
    // Create a basic recipe structure
    return {
      title: title,
      description: `This recipe was extracted from ${url}. The AI analysis is based on the content of the webpage.`,
      ingredients: extractIngredientsList(html) || ["Ingredients could not be automatically extracted"],
      instructions: extractInstructionsList(html) || ["Instructions could not be automatically extracted"],
      prep_time: estimateTime(html, "prep") || 15,
      cook_time: estimateTime(html, "cook") || 30,
      servings: estimateServings(html) || 4,
      difficulty_level: "Medium",
      cuisine: guessCuisine(url, html),
      image_url: extractImageUrl(url, html),
      tags: generateTags(html, title),
      meal_type: guessMealType(html, title)
    };
  } catch (error) {
    console.error("Error fetching or parsing URL:", error);
    
    // If fetching fails, return a very basic placeholder recipe
    const domain = new URL(url).hostname;
    return {
      title: `Recipe from ${domain}`,
      description: `This recipe is based on content from ${url}. We couldn't extract detailed information automatically.`,
      ingredients: ["Ingredients could not be automatically extracted"],
      instructions: ["Please refer to the original recipe at the source URL"],
      prep_time: 15,
      cook_time: 30,
      servings: 4,
      difficulty_level: "Medium",
      cuisine: "Unknown",
      image_url: null,
      tags: ["recipe"],
      meal_type: "Main"
    };
  }
}

// Helper functions for recipe generation
function enhanceExistingRecipe(recipe: any): any {
  // Add any missing fields with reasonable defaults
  const enhanced = { ...recipe };
  
  if (!enhanced.prep_time) enhanced.prep_time = 15;
  if (!enhanced.cook_time) enhanced.cook_time = 30;
  if (!enhanced.servings) enhanced.servings = 4;
  if (!enhanced.difficulty_level) enhanced.difficulty_level = "Medium";
  if (!enhanced.cuisine) enhanced.cuisine = guessCuisineFromTitle(enhanced.title);
  if (!enhanced.tags) enhanced.tags = generateTagsFromTitle(enhanced.title);
  if (!enhanced.meal_type) enhanced.meal_type = guessMealTypeFromTitle(enhanced.title);
  
  // Format ingredients and instructions if needed
  if (enhanced.ingredients && Array.isArray(enhanced.ingredients)) {
    enhanced.ingredients = enhanced.ingredients.map((ingredient: string) => 
      ingredient.trim()).filter(Boolean);
  }
  
  if (enhanced.instructions && Array.isArray(enhanced.instructions)) {
    enhanced.instructions = enhanced.instructions.map((step: string) => 
      step.trim()).filter(Boolean);
  }
  
  return enhanced;
}

function extractIngredientsList(html: string): string[] | null {
  // Look for common ingredient list patterns
  const ingredientPatterns = [
    /<[^>]*?ingredient[^>]*?>([\s\S]*?)<\/[^>]*?>/i,
    /<ul[^>]*?ingredients[^>]*?>([\s\S]*?)<\/ul>/i,
    /<ol[^>]*?ingredients[^>]*?>([\s\S]*?)<\/ol>/i,
    /<div[^>]*?ingredients[^>]*?>([\s\S]*?)<\/div>/i,
    /<section[^>]*?ingredients[^>]*?>([\s\S]*?)<\/section>/i
  ];
  
  for (const pattern of ingredientPatterns) {
    const match = html.match(pattern);
    if (match) {
      // Extract list items
      const items = match[1].match(/<li[^>]*?>([\s\S]*?)<\/li>/gi);
      if (items && items.length > 0) {
        return items.map(item => {
          // Clean HTML tags and normalize whitespace
          const cleaned = item.replace(/<[^>]*?>/g, ' ').replace(/\s+/g, ' ').trim();
          return cleaned;
        }).filter(Boolean);
      }
    }
  }
  
  return null;
}

function extractInstructionsList(html: string): string[] | null {
  // Look for common instruction list patterns
  const instructionPatterns = [
    /<[^>]*?instruction[^>]*?>([\s\S]*?)<\/[^>]*?>/i,
    /<[^>]*?direction[^>]*?>([\s\S]*?)<\/[^>]*?>/i,
    /<[^>]*?method[^>]*?>([\s\S]*?)<\/[^>]*?>/i,
    /<[^>]*?steps[^>]*?>([\s\S]*?)<\/[^>]*?>/i,
    /<ol[^>]*?>([\s\S]*?)<\/ol>/i
  ];
  
  for (const pattern of instructionPatterns) {
    const match = html.match(pattern);
    if (match) {
      // Extract list items
      const items = match[1].match(/<li[^>]*?>([\s\S]*?)<\/li>/gi);
      if (items && items.length > 0) {
        return items.map(item => {
          // Clean HTML tags and normalize whitespace
          const cleaned = item.replace(/<[^>]*?>/g, ' ').replace(/\s+/g, ' ').trim();
          return cleaned;
        }).filter(Boolean);
      }
    }
  }
  
  return null;
}

function estimateTime(html: string, timeType: string): number | null {
  // Look for common time patterns (minutes)
  const timePatterns = [
    new RegExp(`${timeType}[^:]*?:\\s*(\\d+)\\s*min`, 'i'),
    new RegExp(`${timeType}[^:]*?time\\s*[:-]\\s*(\\d+)\\s*min`, 'i'),
    new RegExp(`${timeType}.*?(\\d+)\\s*min`, 'i')
  ];
  
  for (const pattern of timePatterns) {
    const match = html.match(pattern);
    if (match && match[1]) {
      const minutes = parseInt(match[1]);
      if (!isNaN(minutes)) {
        return minutes;
      }
    }
  }
  
  // Default times
  return timeType === "prep" ? 15 : 30;
}

function estimateServings(html: string): number | null {
  // Look for common serving patterns
  const servingPatterns = [
    /serv(es|ings)[^:]*?:\s*(\d+)/i,
    /yield[^:]*?:\s*(\d+)\s*serv/i,
    /serves\s*(\d+)/i,
    /servings\s*[:-]\s*(\d+)/i
  ];
  
  for (const pattern of servingPatterns) {
    const match = html.match(pattern);
    if (match && match[1]) {
      const servings = parseInt(match[1]);
      if (!isNaN(servings)) {
        return servings;
      }
    }
  }
  
  return 4; // Default servings
}

function guessCuisine(url: string, html: string): string {
  // Check URL for cuisine hints
  const urlLower = url.toLowerCase();
  const cuisines = [
    "italian", "french", "mexican", "indian", "thai", "chinese", 
    "japanese", "korean", "spanish", "greek", "mediterranean",
    "american", "cajun", "middle eastern", "moroccan"
  ];
  
  for (const cuisine of cuisines) {
    if (urlLower.includes(cuisine)) {
      return cuisine.charAt(0).toUpperCase() + cuisine.slice(1);
    }
  }
  
  // Check content
  const htmlLower = html.toLowerCase();
  for (const cuisine of cuisines) {
    if (htmlLower.includes(cuisine + " recipe") || 
        htmlLower.includes(cuisine + " cuisine") || 
        htmlLower.includes(cuisine + " dish")) {
      return cuisine.charAt(0).toUpperCase() + cuisine.slice(1);
    }
  }
  
  return "International";
}

function guessCuisineFromTitle(title: string): string {
  const titleLower = title.toLowerCase();
  const cuisines = [
    "italian", "french", "mexican", "indian", "thai", "chinese", 
    "japanese", "korean", "spanish", "greek", "mediterranean",
    "american", "cajun", "middle eastern", "moroccan"
  ];
  
  for (const cuisine of cuisines) {
    if (titleLower.includes(cuisine)) {
      return cuisine.charAt(0).toUpperCase() + cuisine.slice(1);
    }
  }
  
  return "International";
}

function extractImageUrl(url: string, html: string): string | null {
  // Try to find main image
  const patterns = [
    /<meta\s+property=["']og:image["']\s+content=["'](https?:\/\/[^"']+)["']/i,
    /<img[^>]*?class=["'].*?hero.*?["'][^>]*?src=["'](https?:\/\/[^"']+)["']/i,
    /<img[^>]*?class=["'].*?main.*?["'][^>]*?src=["'](https?:\/\/[^"']+)["']/i,
    /<img[^>]*?class=["'].*?recipe.*?["'][^>]*?src=["'](https?:\/\/[^"']+)["']/i,
    /<img[^>]*?src=["'](https?:\/\/[^"']+\.(?:jpg|jpeg|png|webp))["'][^>]*?/i
  ];
  
  for (const pattern of patterns) {
    const match = html.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  
  return null;
}

function generateTags(html: string, title: string): string[] {
  const tags = new Set<string>();
  
  // Add basic tag
  tags.add("recipe");
  
  // Check for common dietary terms
  const dietaryTerms = [
    "vegetarian", "vegan", "gluten-free", "dairy-free", 
    "keto", "paleo", "low-carb", "sugar-free"
  ];
  
  const htmlLower = html.toLowerCase();
  const titleLower = title.toLowerCase();
  
  for (const term of dietaryTerms) {
    if (htmlLower.includes(term) || titleLower.includes(term)) {
      tags.add(term);
    }
  }
  
  // Check for meal types
  const mealTypes = ["breakfast", "lunch", "dinner", "dessert", "snack", "appetizer"];
  for (const type of mealTypes) {
    if (htmlLower.includes(type) || titleLower.includes(type)) {
      tags.add(type);
    }
  }
  
  // Add cuisine if present in title
  const cuisine = guessCuisineFromTitle(title);
  if (cuisine !== "International") {
    tags.add(cuisine.toLowerCase());
  }
  
  return Array.from(tags);
}

function generateTagsFromTitle(title: string): string[] {
  const tags = new Set<string>();
  tags.add("recipe");
  
  const titleLower = title.toLowerCase();
  
  // Check for common dietary terms
  const dietaryTerms = ["vegetarian", "vegan", "gluten-free", "dairy-free", "keto", "paleo"];
  for (const term of dietaryTerms) {
    if (titleLower.includes(term)) {
      tags.add(term);
    }
  }
  
  // Check for meal types
  const mealTypes = ["breakfast", "lunch", "dinner", "dessert", "snack", "appetizer"];
  for (const type of mealTypes) {
    if (titleLower.includes(type)) {
      tags.add(type);
    }
  }
  
  // Add cuisine if present in title
  const cuisine = guessCuisineFromTitle(title);
  if (cuisine !== "International") {
    tags.add(cuisine.toLowerCase());
  }
  
  return Array.from(tags);
}

function guessMealType(html: string, title: string): string {
  const htmlLower = html.toLowerCase();
  const titleLower = title.toLowerCase();
  
  // Check for explicit meal types
  if (titleLower.includes("breakfast") || htmlLower.includes("breakfast recipe")) {
    return "Breakfast";
  }
  if (titleLower.includes("lunch") || htmlLower.includes("lunch recipe")) {
    return "Lunch";
  }
  if (titleLower.includes("dinner") || htmlLower.includes("dinner recipe")) {
    return "Dinner";
  }
  if (titleLower.includes("dessert") || 
      titleLower.includes("cake") || 
      titleLower.includes("cookie") || 
      titleLower.includes("pie") ||
      htmlLower.includes("dessert recipe")) {
    return "Dessert";
  }
  if (titleLower.includes("snack") || htmlLower.includes("snack recipe")) {
    return "Snack";
  }
  if (titleLower.includes("appetizer") || 
      titleLower.includes("starter") || 
      htmlLower.includes("appetizer recipe")) {
    return "Appetizer";
  }
  
  // Default to Dinner for most recipes
  return "Dinner";
}

function guessMealTypeFromTitle(title: string): string {
  const titleLower = title.toLowerCase();
  
  // Check for explicit meal types
  if (titleLower.includes("breakfast")) {
    return "Breakfast";
  }
  if (titleLower.includes("lunch")) {
    return "Lunch";
  }
  if (titleLower.includes("dinner")) {
    return "Dinner";
  }
  if (titleLower.includes("dessert") || 
      titleLower.includes("cake") || 
      titleLower.includes("cookie") || 
      titleLower.includes("pie")) {
    return "Dessert";
  }
  if (titleLower.includes("snack")) {
    return "Snack";
  }
  if (titleLower.includes("appetizer") || titleLower.includes("starter")) {
    return "Appetizer";
  }
  
  // Default to Dinner for most recipes
  return "Dinner";
}
